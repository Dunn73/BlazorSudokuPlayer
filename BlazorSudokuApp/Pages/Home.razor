@page "/"
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject HttpClient Http
@inject Microsoft.JSInterop.IJSRuntime JSRuntime
@using Models.Sudoku;
@using Controllers.SudokuSolver;
@using System.Text;
@using System.Diagnostics

<style>
    body {
        background-color: aliceblue;
        
    }
    button {
        background-color: #d0f5f1;
        border-radius: 5px;
        font-weight: bold;
    }
    .highlighted {
        background-color: lightyellow; /* Change this color as desired */
    }
    .notes {
        font-size: 0.6em; /* Adjust the size of the notes */
    }
    .note-item {
        margin-right: 4px; /* Adjust the margin to increase or decrease spacing */
        margin-left: 4px;
        margin-bottom: -0.7px;
        font-weight: bold;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
</style>

<div style="display: flex; flex-direction: column; align-items: center;">
    <h1 style="margin-right: 88px;">@($"Sudoku {puzzleId}")</h1>

    <div style="display: flex; align-items: center;">
        <table border="5" cellpadding="0" cellspacing="0">
            @for (int i = 0; i < 9; i += 3)
            {
                <tr>
                    @for (int j = 0; j < 9; j += 3)
                    {
                        <td>
                            <table border="1" cellpadding="2">
                                @for (int k = 0; k < 3; k++)
                                {
                                    <tr>
                                        @for (int l = 0; l < 3; l++)
                                        {
                                            var rowIndex = i + k;
                                            var colIndex = j + l;
                                            <td @onmousedown="(e) => HandleMouseDown(e, rowIndex, colIndex)"style="border: 2px solid black; position: relative;">
                                                <input @bind="@GridValues[rowIndex, colIndex]" type="text" min="1" max="9" required size="1" maxlength="1"
                                                       @oninput="async (e) => await SaveTextToLocalStorage(rowIndex, colIndex, e)"
                                                       onkeypress="return event.key >= '1' && event.key <= '9'"
                                                       @onkeydown:preventDefault="@isPreventKey"
                                                       @onkeydown="e => HandleKeyDown(e, rowIndex, colIndex)"
                                                       @onmousedown="(e) => HandleMouseDown(e, rowIndex, colIndex)"
                                                       @ref="inputCells[rowIndex, colIndex]"
                                                       class="@((currentRowIndex == rowIndex && currentColIndex == colIndex) ? "highlighted" : "")"
                                                       style="color: @GridColors[rowIndex, colIndex]; width: 50px; height: 50px; text-align: center; font-size: 2.3em; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;"
                                                       readonly="@(given[rowIndex, colIndex])"
                                                />
                                                <div class="notes" style="position: absolute; top: 0; left: 0; right: 0; text-align: center;">
                                                    @for (int rowOffset = 0; rowOffset < 3; rowOffset++)
                                                    {
                                                        <div style="display: flex; justify-content: center;">
                                                            @for (int colOffset = 0; colOffset < 3; colOffset++)
                                                            {
                                                                int note = rowOffset * 3 + colOffset + 1;
                                                                if (GridNotes[rowIndex, colIndex] != null && GridNotes[rowIndex, colIndex].Contains(note) && GridValues[rowIndex, colIndex] == null)
                                                                {
                                                                    <span style="font-size: 1.3em;" class="note-item">@note</span>
                                                                }
                                                            }
                                                        </div>
                                                    }
                                                </div>
                                            </td>
                                        }
                                    </tr>
                                }
                            </table>
                        </td>
                    }
                </tr>
            }
        </table>

        <div style="margin-left: 20px; display: flex; flex-direction: column;"> <!-- Adjust margin-left and flex-direction as needed -->
            <button @onclick="SolveSudoku" style="margin-top: 10px; margin-bottom: 10px; height: 40px;">Solve</button>
            <button @onclick="UnsolveSudoku" style="margin-top: 10px; height: 40px;">Unsolve</button>
            <button @onclick="SolveTile" style="margin-top: 50px;">Solve<br>Tile</button>
        </div>
    </div>

    <div style="margin-top: 10px; display: flex; justify-content: center; margin-right: 80px;"> <!-- Adjust margin-top and other styles as needed -->
        <div style="display: flex; justify-content: center; width: 100%;"> <!-- New container for the buttons with width constraint -->
            <button @onclick="GenerateSudoku"  style=" margin-right: 25px; height">Generate Board</button>
            <button @onclick="WipeBoard" style=" margin-right: 25px;">Clear Board</button>
            <button @onclick="ToggleNotesMode" title="Toggle notes with Spacebar" style=" margin-right: 9px;">Notes (Spacebar)</button>
            <div class="alert alert-@($"{noteMessageColor}")" role="alert" style="text-align: center; height: 30px; font-size: 12px;
            justify-content: center; display: flex; align-items: center;">@($"{noteMessage}")
            </div>
        </div>
    </div>

    <div class="alert alert-primary" role="alert" style="margin-top: 10px; height: 50px; width: 350px; margin-right: 95px; text-align: center;">
    @($"{alertMessage}")
</div>
</div>

@code {
    char?[,] Sudoku = new char?[9,9];
    char?[,] GridValues = new char?[9, 9]; 
    string[,] GridColors = new string[9, 9]; // Add this line to declare GridColors array
    bool[,] given = new bool[9, 9];
    List<int>?[,] GridNotes = new List<int>?[9, 9];
    bool[,] originalReadOnlyStatus = new bool[9, 9];
    int currentRowIndex = 4;
    int currentColIndex = 4;
    public ElementReference[,] inputCells = new ElementReference[9, 9];
    public SudokuInfo[]? sudokuInfo;
    public Solver? solver = new();
    Stopwatch solveTimer = new();
    private bool isPreventKey = false;  // Used to conditionally set some key handlers to be default
    bool isNotesMode = false;   // Toggles note mode
    string puzzleId;
    string alertMessage;
    string noteMessage = "Off";
    string noteMessageColor = "danger";
    

    void ToggleNotesMode() {
        isNotesMode = !isNotesMode;
        
        if (isNotesMode) {
            noteMessageColor="success";
            noteMessage = "On";
            for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                originalReadOnlyStatus[i, j] = given[i, j];
                given[i, j] = true; // Set all cells as readonly
            }
        }
            Console.WriteLine("Set to notes mode");
        }
        
        else {
            noteMessageColor="danger";
            noteMessage = "Off";
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    given[i, j] = originalReadOnlyStatus[i, j];
                }
            }
            Console.WriteLine("Notes mode off");
        }
        inputCells[currentRowIndex, currentColIndex].FocusAsync();
    }
    async Task SolveSudoku(){
        
        var puzzleInfo = await localStorage.GetItemAsync<SudokuInfo>("currentPuzzle");
        if (puzzleInfo.Id != null){
            if (puzzleInfo.CurrentPuzzle != puzzleInfo.Solution){
                for (int i = 0; i < puzzleInfo.CurrentPuzzle.Length; i++){
                    if (puzzleInfo.CurrentPuzzle[i] == '.')
                    GridColors[i/9, i%9] = "#cc3535";
                    GridValues[i/9, i%9] = puzzleInfo.Solution[i];
                }
            }
        }
        else {
        string sudoku = puzzleInfo.CurrentPuzzle;
        var output = solver.SolveSudoku(sudoku);
        if (sudoku == output){
            alertMessage="This is a solved Sudoku";
        }
        else if (output == "invalid board"){
            alertMessage = "Invalid Board";
        }
        else if (output == "no solution"){
            alertMessage = "No Solution";
        }
        else {
            for (int i = 0; i < sudoku.Length; i++){
                    if (puzzleInfo.CurrentPuzzle[i] == '.')
                    GridColors[i/9, i%9] = "#cc3535";
                    GridValues[i/9, i%9] = output[i];
                }
            alertMessage="Sudoku solved";
        }
        }
        inputCells[currentRowIndex, currentColIndex].FocusAsync();
        
    }
    async Task SolveTile() {
        var puzzleInfo = await localStorage.GetItemAsync<SudokuInfo>("currentPuzzle");
        StringBuilder puzzleUpdater = new StringBuilder(puzzleInfo.CurrentPuzzle);
        
        if (puzzleInfo.Id != null){
            if (puzzleInfo.Puzzle[currentRowIndex*9 + currentColIndex] == '.' ){
                GridValues[currentRowIndex, currentColIndex] = puzzleInfo.Solution[currentRowIndex*9 + currentColIndex];
                puzzleUpdater[currentRowIndex*9 + currentColIndex] = puzzleInfo.Solution[currentRowIndex*9 + currentColIndex];
                puzzleInfo.CurrentPuzzle = puzzleUpdater.ToString();

                // Check if there is a user input for this cell
                    var userInput = puzzleInfo.userInputs.FirstOrDefault(x => x.Item1 == currentRowIndex && x.Item2 == currentColIndex);
                    if (userInput == default) {
                        puzzleInfo.userInputs.Add((currentRowIndex, currentColIndex, puzzleInfo.Solution[currentRowIndex*9 + currentColIndex]));
                    }
                    else {
                        var tupleToRemove = puzzleInfo.userInputs.FirstOrDefault(t => t.Item1 == currentRowIndex && t.Item2 == currentColIndex);
                        puzzleInfo.userInputs.Remove(tupleToRemove);
                        puzzleInfo.userInputs.Add((currentRowIndex, currentColIndex, puzzleInfo.Solution[currentRowIndex*9 + currentColIndex]));
                    }
                await localStorage.SetItemAsync("currentPuzzle", puzzleInfo);
            }
        }
        inputCells[currentRowIndex, currentColIndex].FocusAsync();
    }
    async Task UnsolveSudoku() {
        var puzzleInfo = await localStorage.GetItemAsync<SudokuInfo>("currentPuzzle");
        if (puzzleInfo.Id != null){
            await PopulateGridFromLocalStorage();
        }
        else {

            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    GridColors[i, j] = "black";
                    if (puzzleInfo.CurrentPuzzle[i*9 + j] == '.'){
                        GridValues[i,j] = null;
                    }
                    

                    // Check if there is a user input for this cell
                    var userInput = puzzleInfo.userInputs.FirstOrDefault(x => x.Item1 == i && x.Item2 == j);
                    if (userInput != default) {
                        GridValues[i, j] = userInput.Item3;
                    }
                    // Initialize notes list for each cell
                    GridNotes[i, j] = new List<int>();
                    // Populate notes from puzzleInfo.Notes
                    var cellNotes = puzzleInfo.Notes.FirstOrDefault(n => n.Item1 == i && n.Item2 == j);
                    if (cellNotes != default) {
                        foreach (var note in cellNotes.Item3) {
                            if (note.Item2) {
                                GridNotes[i, j].Add(int.Parse(note.Item1.ToString()));
                            }
                        }
                    }
                }
        }

        }
        inputCells[currentRowIndex, currentColIndex].FocusAsync();
        
    }
    async Task MoveCaretToEnd() {
        await JSRuntime.InvokeVoidAsync("moveCaretToEnd", inputCells[currentRowIndex, currentColIndex]);
    }

    protected override async Task OnInitializedAsync(){
        sudokuInfo = await Http.GetFromJsonAsync<SudokuInfo[]>("sample-data/ValidSudokus.json");
        await PopulateGridFromLocalStorage(); // Populate the grid from local storage
        await inputCells[4,4].FocusAsync();
    }
    async Task GenerateSudoku(){
        await WipeBoard();

        Random random = new Random();
        int randomNumber = random.Next(sudokuInfo.Length);

        await SaveGridToLocalStorage(randomNumber);

        var currentInfo = await localStorage.GetItemAsync<SudokuInfo>("currentPuzzle");
        currentInfo.CurrentPuzzle = currentInfo.Puzzle;
        await localStorage.SetItemAsync("currentPuzzle", currentInfo);

      
        string? puzzle = sudokuInfo[randomNumber].Puzzle;

        int index = 0;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                GridColors[i,j] = "black";
                GridValues[i, j] = puzzle[index++];
                if (GridValues[i, j] != null) {
                    char value = GridValues[i, j].Value;
                    if (value == '.'){
                        GridValues[i, j] = null;
                    }
                    else {
                        // Change the color based on the value
                        GridColors[i,j] = "blue";
                        given[i, j] = true; // Set given flag to true for blue numbers
                        
                    }
                }
            }
        }
        puzzleId = "# " + currentInfo.Id.ToString();
        alertMessage = $"Sudoku # {currentInfo.Id} Generated";
        await inputCells[currentRowIndex,currentColIndex].FocusAsync();
     }
    async Task SaveTextToLocalStorage(int row, int col, ChangeEventArgs e){
        var puzzleInfo = await localStorage.GetItemAsync<SudokuInfo>("currentPuzzle");
        StringBuilder puzzleUpdater = new StringBuilder(puzzleInfo.CurrentPuzzle); 
        
        try {
            char key = Convert.ToChar(e.Value);
            puzzleUpdater[row*9 + col] = key;
            puzzleInfo.userInputs.Add((row,col,key));
            puzzleInfo.CurrentPuzzle = puzzleUpdater.ToString();
            if (puzzleInfo.Id != null){
                if (puzzleInfo.CurrentPuzzle == puzzleInfo.Solution){
                    alertMessage = $"Congratulations! Sudoku solved in ";
                }
            }
            
        }
        catch {
            var tupleToRemove = puzzleInfo.userInputs.FirstOrDefault(t => t.Item1 == row && t.Item2 == col);    // Searches for the cell to remove the tuple from
            puzzleInfo.userInputs.Remove(tupleToRemove);
            puzzleUpdater[row*9 + col] = '.';
            puzzleInfo.CurrentPuzzle = puzzleUpdater.ToString();
        }
        if (solver.BoardValidator(puzzleInfo.CurrentPuzzle).Item1 == false){
            alertMessage = $"Duplicates: {solver.BoardValidator(puzzleInfo.CurrentPuzzle).Item2}";
        }
        else{
            
            try{
                if  (alertMessage.Contains("Duplicate")){
                    alertMessage = "Board now Valid";
                }
            }
            catch {

            }
    }

        await localStorage.SetItemAsync("currentPuzzle", puzzleInfo);

    }
    async Task SaveGridToLocalStorage(int puzzleId) { 

        await localStorage.SetItemAsync<SudokuInfo>($"currentPuzzle", sudokuInfo[puzzleId]);    // Sets the generated puzzle as the current puzzle in local storage
    }
    async Task WipeGridFromLocalStorage() {
        var sudokuInfo = new SudokuInfo(); // Create an instance of SudokuInfo
        await localStorage.RemoveItemAsync("currentPuzzle");                // Removes the current board from local storage
        var emptySudokuInfo = sudokuInfo.GenerateEmptySudoku();                        // Creates an empty board Json
        await localStorage.SetItemAsync("currentPuzzle", emptySudokuInfo);  // Adds the empty board Json to local storage
    }
    async Task WipeBoard(){
        alertMessage="Board Cleared";
        puzzleId ="";
        for (int i = 0; i < 9; i++){
            for (int j = 0; j < 9; j++){
                GridValues[i, j] = null;
                GridColors[i, j] = "black"; // Reset cell color
                given[i, j] = false; // Reset readonly status
                GridNotes[i,j] = [];
                if (isNotesMode){
                    isNotesMode = false;
                }
            }
        }
    
    // Remove the current puzzle from local storage and add an empty one
    await WipeGridFromLocalStorage();
    
    // Set focus to the first cell
    await inputCells[currentRowIndex, currentColIndex].FocusAsync();
    }

    async Task PopulateGridFromLocalStorage() {
    var puzzleInfo = await localStorage.GetItemAsync<SudokuInfo>("currentPuzzle");
    if (puzzleInfo == null) {
        // If no puzzle info found or incomplete puzzle info, generate an empty sudoku
        var sudokuInfo = new SudokuInfo();
        var emptySudokuInfo = sudokuInfo.GenerateEmptySudoku();
        await localStorage.SetItemAsync("currentPuzzle", emptySudokuInfo);
    }
    else {
        if (puzzleInfo.Id.ToString() !="")
        puzzleId = "# " + puzzleInfo.Id.ToString();

        // If puzzle info found, populate the grid from it
        string puzzle = puzzleInfo.Puzzle;
        
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                GridColors[i, j] = "black";
                if (puzzle != ""){
                    GridValues[i, j] = puzzle[i * 9 + j];
                }
                // Check if cell value is not null and not a '.'
                if (GridValues[i, j] != null && GridValues[i, j] != '.') {
                    GridColors[i, j] = "blue"; // Set color to blue for non-empty cells
                    given[i, j] = true; // Set the cell as given (readonly)
                }
                else {
                    GridValues[i, j] = null; // Clear cell value if it's '.'
                    given[i, j] = false; // Set the cell as not given (not readonly)
                }

                // Check if there is a user input for this cell
                var userInput = puzzleInfo.userInputs.FirstOrDefault(x => x.Item1 == i && x.Item2 == j);
                if (userInput != default) {
                    GridValues[i, j] = userInput.Item3;
                }
                // Initialize notes list for each cell
                GridNotes[i, j] = new List<int>();
                // Populate notes from puzzleInfo.Notes
                var cellNotes = puzzleInfo.Notes.FirstOrDefault(n => n.Item1 == i && n.Item2 == j);
                if (cellNotes != default) {
                    foreach (var note in cellNotes.Item3) {
                        if (note.Item2) {
                            GridNotes[i, j].Add(int.Parse(note.Item1.ToString()));
                        }
                    }
                }
            }
        }
    }
}

    async Task HandleKeyDown(KeyboardEventArgs e, int row, int col){
        if (e.Key == "ArrowUp" || e.Key == "w"){
            if (row > 0){
            this.isPreventKey = true;
            currentRowIndex = row - 1;
            currentColIndex = col;
            }
            else {
                this.isPreventKey = true;
                currentRowIndex = 8;
                currentColIndex = col;
            }
        }
        else if (e.Key == "ArrowDown" || e.Key == "s"){
            if (row < 8){
            this.isPreventKey = true;
            currentRowIndex = row + 1;
            currentColIndex = col;
            }
            else {
                this.isPreventKey = true;
                currentRowIndex = 0;
                currentColIndex = col;
            }
        }
        else if (e.Key == "ArrowLeft" || e.Key == "a" || e.Key == "q"){
            if (col > 0){
            this.isPreventKey = true;
            currentRowIndex = row;
            currentColIndex = col - 1;
            }
            else {
                this.isPreventKey = true;
                currentRowIndex = row;
                currentColIndex = 8;
            }
        }
        else if (e.Key == "ArrowRight" || e.Key == "d" || e.Key == "e"){
            if (col < 8){
            this.isPreventKey = true;
            currentRowIndex = row;
            currentColIndex = col + 1;
            }
            else {
                this.isPreventKey = true;
                currentRowIndex = row;
                currentColIndex = 0;
            }
        }
        else if (e.Key == "Tab") {
            this.isPreventKey = true;
            if (col !=8 || row !=8){
                if (col !=8){
                    currentColIndex = col+1;
                    currentRowIndex = row;
                }
                else {
                    currentColIndex = 0;
                    currentRowIndex = row+1;
                }
            }
        }
        else if (e.Key == " ") {
            this.isPreventKey = true;
            ToggleNotesMode();
        }
        else if ((e.Key == "1" || e.Key == "2" || e.Key == "3" || e.Key == "4" || e.Key == "5" || e.Key == "6" || e.Key == "7" || e.Key == "8" || e.Key == "9") 
            && isNotesMode){
                var key = int.Parse(e.Key);
                if (GridNotes[row, col].Contains(key)) {
                    GridNotes[row, col].Remove(key);
                }
                else {
                    GridNotes[row, col].Add(key);
                }
            await inputCells[row, col].FocusAsync();
                this.isPreventKey = true;
                var puzzleInfo = await localStorage.GetItemAsync<SudokuInfo>("currentPuzzle");
                
                // Check if the Notes list contains a note at the specified row and col
                var existingNoteIndex = puzzleInfo.Notes.FindIndex(note => note.Item1 == row && note.Item2 == col);

                if (existingNoteIndex != -1) {
                    // If the note exists, get the list of tuples and add the new tuple to it
                    var tuples = puzzleInfo.Notes[existingNoteIndex].Item3;
                    var existingTupleIndex = tuples.FindIndex(tuple => tuple.Item1 == Convert.ToChar(e.Key));
                    if (existingTupleIndex != -1) {
                         // If the tuple exists, toggle the boolean value in the second item
                        tuples[existingTupleIndex] = (tuples[existingTupleIndex].Item1, !tuples[existingTupleIndex].Item2);
                    }
                    else {
                        // If the tuple does not exist, add a new tuple to the list
                        tuples.Add((Convert.ToChar(e.Key), true));
                    }
                }
                else {
                    // If the note does not exist, add a new note with the tuple
                    puzzleInfo.Notes.Add((row, col, new List<(char, bool)> { (Convert.ToChar(e.Key), true) }));
                }
                await localStorage.SetItemAsync("currentPuzzle", puzzleInfo);
        }
        else if (e.Key == "Backspace"){
            if (isNotesMode){
                var currentPuzzle = await localStorage.GetItemAsync<SudokuInfo>("currentPuzzle");
                this.isPreventKey = true;

                GridNotes[row, col] = [];
                currentPuzzle.Notes = currentPuzzle.Notes.Where(tuple => tuple.Item1 != row || tuple.Item2 != col).ToList();
                await localStorage.SetItemAsync("currentPuzzle", currentPuzzle);

            }
            Console.WriteLine("Backspace was pressed");
        }
        await inputCells[currentRowIndex, currentColIndex].FocusAsync();
        await MoveCaretToEnd();
        this.isPreventKey = false;
    }
    async Task HandleMouseDown(MouseEventArgs e, int row, int col) {
        Console.WriteLine($"Handle Mouse Down is being registered");
        currentRowIndex = row;
        currentColIndex = col;
        await inputCells[currentRowIndex, currentColIndex].FocusAsync();
    }
    
}
