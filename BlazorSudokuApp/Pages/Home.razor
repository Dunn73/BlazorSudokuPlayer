@page "/"
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject HttpClient Http
@inject Microsoft.JSInterop.IJSRuntime JSRuntime

<h1>9x9 Sudoku</h1>

    <table border="5" cellpadding="0" cellspacing="0">
    @for (int i = 0; i < 9; i += 3)
    {
        <tr>
            @for (int j = 0; j < 9; j += 3)
            {
                <td>
                    <table border="1" cellpadding="2">
                        @for (int k = 0; k < 3; k++)
                        {
                            <tr>
                                @for (int l = 0; l < 3; l++)
                                {
                                    var rowIndex = i + k;
                                    var colIndex = j + l;
                                    
                                    var isVisible = currentRowIndex == i && currentColIndex == j;
                                    <td style="border: 3px solid black;">
                                        <input @bind="@GridValues[rowIndex, colIndex]" type="text" min="1" max="9" required size="1" maxlength="1" 
                                               @oninput="async (e) => await SaveTextToLocalStorage(rowIndex, colIndex, e)"
                                               onkeypress="return event.key >= '1' && event.key <= '9'"
                                               @onkeydown:preventDefault="@isPreventKey"
                                               @onkeydown="e => HandleKeyDown(e, rowIndex, colIndex)"
                                               @onmousedown="(e) => HandleMouseDown(e, rowIndex, colIndex)"
                                               @ref="inputCells[rowIndex, colIndex]"
                                               style="color: @GridColors[rowIndex, colIndex]; width: 50px; height: 50px; text-align: center; font-size: 2.3em;"
                                               readonly="@(GridColors[rowIndex, colIndex] == "blue" ? true : false)"
                                               />
                                    </td>
                                }
                            </tr>
                        }
                    </table>
                </td>
            }
        </tr>
    }
    </table>
    <div style="margin-top: 10px;"> <!-- Adjust margin-top as needed -->
    <button @onclick="GenerateSudoku">Generate Board</button>
    <button @onclick="WipeBoard" style="margin-left: 10px;">Clear Board</button> <!-- Adjust margin-left as needed -->
    </div>

    

@code {
    char?[,] GridValues = new char?[9, 9]; 
    string[,] GridColors = new string[9, 9]; // Add this line to declare GridColors array
    int currentRowIndex = 0;
    int currentColIndex = 0;
    public ElementReference[,] inputCells = new ElementReference[9, 9];
    public SudokuInfo[]? sudokuInfo;
    private bool isPreventKey = false;  // Used to conditionally set some key handlers to be default

    async Task MoveCaretToEnd() {
        await JSRuntime.InvokeVoidAsync("moveCaretToEnd", inputCells[currentRowIndex, currentColIndex]);
    }

    protected override async Task OnInitializedAsync(){
        sudokuInfo = await Http.GetFromJsonAsync<SudokuInfo[]>("sample-data/ValidSudokus.json");
        await PopulateGridFromLocalStorage(); // Populate the grid from local storage
    }
    async Task GenerateSudoku(){
        await WipeGridFromLocalStorage();

        Random random = new Random();
        int randomNumber = random.Next(sudokuInfo.Length);

        await SaveGridToLocalStorage(randomNumber);

        string? puzzle = await localStorage.GetItemAsync<string>("currentPuzzle");
        puzzle = sudokuInfo[randomNumber].Puzzle;

        int index = 0;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                GridColors[i,j] = "black";
                GridValues[i, j] = puzzle[index++];
                if (GridValues[i, j] != null) {
                    char value = GridValues[i, j].Value;
                    if (value == '.'){
                        GridValues[i, j] = null;
                    }
                    else {
                        // Change the color based on the value
                        GridColors[i,j] = "blue";
                        
                    }
                }
            }
        }
     }
    async Task SaveTextToLocalStorage(int row, int col, ChangeEventArgs e){
        Console.WriteLine($"Saving value at row {row}, column {col}");
        var puzzleInfo = await localStorage.GetItemAsync<SudokuInfo>("currentPuzzle");
        
        
        try {
            char key = Convert.ToChar(e.Value);
            puzzleInfo.userInputs.Add((row,col,key));

        }
        catch {
        var tupleToRemove = puzzleInfo.userInputs.FirstOrDefault(t => t.Item1 == row && t.Item2 == col);    // Searches for the cell to remove the tuple from
        puzzleInfo.userInputs.Remove(tupleToRemove);

        }
        await localStorage.SetItemAsync("currentPuzzle", puzzleInfo);

    }
    async Task SaveGridToLocalStorage(int puzzleId) { 

        await localStorage.SetItemAsync<SudokuInfo>($"currentPuzzle", sudokuInfo[puzzleId]);    // Sets the generated puzzle as the current puzzle in local storage
    }
    async Task WipeGridFromLocalStorage() {

        
        await localStorage.RemoveItemAsync("currentPuzzle");                // Removes the current board from local storage
        var emptySudokuInfo = GenerateEmptySudoku();                        // Creates an empty board Json
        await localStorage.SetItemAsync("currentPuzzle", emptySudokuInfo);  // Adds the empty board Json to local storage
    }
    async Task WipeBoard(){
        for (int i = 0; i < 9; i++){
            for (int j = 0; j < 9; j++){
                GridValues[i, j] = null;
                GridColors[i,j] = "black"; // Changes the color of the number in the grid to turn off readonly
            }
        }
        await WipeGridFromLocalStorage(); // Call the method after clearing the grid in memory
    }

    async Task PopulateGridFromLocalStorage() {
        
        var puzzleInfo = await localStorage.GetItemAsync<SudokuInfo>("currentPuzzle");  // Create variable to hold the Json of held sudoku info
        if (puzzleInfo == null){
            var emptySudokuInfo = GenerateEmptySudoku();
            await localStorage.SetItemAsync<SudokuInfo>("currentPuzzle", emptySudokuInfo);
        }
        else if (puzzleInfo.Id == null){
            int index = 0;
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    if (puzzleInfo.userInputs.FirstOrDefault(x => x.Item1 == i && x.Item2 == j) != default){
                        GridValues[i,j] = puzzleInfo.userInputs.FirstOrDefault(x => x.Item1 == i && x.Item2 == j).Item3; 
                    }

                    if (GridValues[i, j] != null) {
                        char value = GridValues[i, j].Value;
                        if (value == '.'){
                            GridValues[i, j] = null;
                        }
                        else {
                            
                        }
                    }
                }
            }
        }
        else {

            string puzzle = puzzleInfo.Puzzle;
            int index = 0;
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    GridColors[i,j] = "black";
                    GridValues[i, j] = puzzle[index++];
                    if (GridValues[i, j] != null) {
                        char value = GridValues[i, j].Value;
                        if (value == '.'){
                            GridValues[i, j] = null;
                        }
                        else {
                            GridColors[i,j] = "blue";
                            
                        }
                        if (puzzleInfo.userInputs.FirstOrDefault(x => x.Item1 == i && x.Item2 == j) != default){
                        GridValues[i,j] = puzzleInfo.userInputs.FirstOrDefault(x => x.Item1 == i && x.Item2 == j).Item3; 
                    }
                    }
                }
            }
        }
    }
    public SudokuInfo GenerateEmptySudoku(){
        var emptySudokuInfo = new SudokuInfo{
                Id = null,
                Puzzle = "",
                Solution = "",
                GivenNumbers = 0,
                userInputs = []
            };
        return emptySudokuInfo;
    }

    async Task HandleKeyDown(KeyboardEventArgs e, int row, int col){
        if (e.Key == "ArrowUp" && row > 0){
            this.isPreventKey = true;
            Console.WriteLine($"Key Pressed: {e.Key}");
            Console.WriteLine($"Current cell is: [{row}, {col}]");
            currentRowIndex = row - 1;
            currentColIndex = col;}
        else if (e.Key == "ArrowDown" && row < 8){
            this.isPreventKey = true;
            Console.WriteLine($"Key Pressed: {e.Key}");
            currentRowIndex = row + 1;
            currentColIndex = col;}
        else if (e.Key == "ArrowLeft" && col > 0){
            this.isPreventKey = true;
            Console.WriteLine($"Key Pressed: {e.Key}");
            currentRowIndex = row;
            currentColIndex = col - 1;
        }
        else if (e.Key == "ArrowRight" && col < 8){
            this.isPreventKey = true;
            Console.WriteLine($"Key Pressed: {e.Key}");
            currentRowIndex = row;
            currentColIndex = col + 1;
        }
        else if (e.Key == "Tab") {
            this.isPreventKey = true;
            Console.WriteLine("Tab was pushed");
            if (col !=8 || row !=8){
                if (col !=8){
                    currentColIndex = col+1;
                    currentRowIndex = row;
                }
                else {
                    currentColIndex = 0;
                    currentRowIndex = row+1;
                }
            }
            Console.WriteLine($"col = {col}, row = {row}, currentColIndex = {currentColIndex}, currentRowIndex = {currentRowIndex}");
        }
        await inputCells[currentRowIndex, currentColIndex].FocusAsync();
        await MoveCaretToEnd();
        this.isPreventKey = false;
    }
    async Task HandleMouseDown(MouseEventArgs e, int row, int col) {
        currentRowIndex = row;
        currentColIndex = col;
        await inputCells[currentRowIndex, currentColIndex].FocusAsync();
    }
    

    public class SudokuInfo {
        public int? Id {get; set;}
        public string? Puzzle { get; set; }
        public string? Solution { get; set; }
        public int? GivenNumbers { get; set; }
        public List<(int, int, char)>? userInputs {get; set;} = new List<(int, int, char)>();
    }
}